options { NODE_DEFAULT_VOID = true; NODE_PREFIX = ""; }

PARSER_BEGIN(OlapQlParser)
package br.com.bi.model.query.grammar;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class OlapQlParser {
  public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(("select [teste];([teste], [teste])"
                + " on columns, [teste] on rows "
                + "from [teste] "
                + "where [teste] = 1 or [teste] and not [teste] > (1 + 2 * 5)").getBytes());

        OlapQlParser parser = new OlapQlParser(in);
        try {
            SimpleNode node = parser.query();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
  }
}
PARSER_END(OlapQlParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LPAR: "(" >
| < RPAR: ")" >
| < LBRA: "[" >
| < RBRA: "]" >
| < COMMA: "," >
| < NODE_SEPARATOR: ";" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < SELECT: "select" >
| < ON: "on" >
| < ROWS: "rows" >
| < COLUMNS: "columns" >
| < FROM: "from" >
| < WHERE: "where" >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

/* ==================== */
/* = Production rules = */
/* ==================== */

SimpleNode query() #Query : 
{}
{
    <SELECT> columns() <ON> <COLUMNS> <COMMA> rows() <ON> <ROWS> <FROM> cube() <WHERE> filterExpression() <EOF> 
    
    {
        return jjtThis;
    }
}

void columns() #Columns     : {} { nodeExp() }

void rows() #Rows           : {} { nodeExp() }

void nodeExp()              : {} { node() (<NODE_SEPARATOR> node())* }

void node()                 : {} { (<METADATA_OBJECT_NAME>) #MetadataObject | crossJoin() #Crossjoin } // [filter], [level], [measure] or a crossjoin

void crossJoin()            : {} { <LPAR> nodeExp() #CrossjoinFirstParam <COMMA> nodeExp() #CrossjoinSecondParam <RPAR> }

void cube() #Cube           : {} { <METADATA_OBJECT_NAME> }

/* ===================== */
/* = filter expression = */
/* ===================== */

void filterExpression() #Filter : {} { disjunction() }

void disjunction()              : {} { ( conjunction() ( <OR> conjunction() )* ) #Disjunction(>1)}

void conjunction()              : {} { ( term() ( <AND> term() )* ) #Conjunction(>1)}

void term()                     : {} { atom() | negation() }

void atom()                     : {} { comparison() | <LPAR> filterExpression() <RPAR>  }

void negation() #Negation       : {} { <NOT> ( term() ) }

void comparison()               : {} { <METADATA_OBJECT_NAME> [ <DOT> <METADATA_OBJECT_NAME> ] [ <RELATIONAL_OPERATOR> operating() ] } // [measure] > 1 or [level].[property] = "foo"

void operating()                : {} { <DATE> | <STRING_LITERAL> | arithmeticExpression() }

/* ========================= */
/* = arithmetic expression = */
/* ========================= */

void arithmeticExpression()     : {} { additiveExpression() }

void additiveExpression()       : {} { multiplicativeExpression() ( ( <PLUS> | <MINUS> ) multiplicativeExpression() )* }

void multiplicativeExpression() : {} { unaryExpression() ( ( <MULT> | <DIV> ) unaryExpression() )* }

void unaryExpression()          : {} { <LPAR> arithmeticExpression() <RPAR> | <METADATA_OBJECT_NAME> | number() }

void number()                   : {} { [ <MINUS> ] ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> )  }
