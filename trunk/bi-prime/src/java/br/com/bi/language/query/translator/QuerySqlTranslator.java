/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package br.com.bi.language.query.translator;

import br.com.bi.language.filter.FilterParserTreeConstants;
import br.com.bi.language.filter.translator.FilterSqlTranslator;
import br.com.bi.language.measure.translator.MeasureSqlTranslator;
import br.com.bi.language.query.Addition;
import br.com.bi.language.query.Conjunction;
import br.com.bi.language.query.Cube;
import br.com.bi.language.query.Date;
import br.com.bi.language.query.Disjunction;
import br.com.bi.language.query.Filter;
import br.com.bi.language.query.FilterExpression;
import br.com.bi.language.query.LevelOrMeasure;
import br.com.bi.language.query.LevelOrMeasureOrFilter;
import br.com.bi.language.query.Measure;
import br.com.bi.language.query.Multiplication;
import br.com.bi.language.query.Negation;
import br.com.bi.language.query.Property;
import br.com.bi.language.query.RelationalOperator;
import br.com.bi.language.query.Select;
import br.com.bi.language.query.SimpleNode;
import br.com.bi.language.query.StringLiteral;
import br.com.bi.language.utils.MetadataCache;
import br.com.bi.language.utils.TranslationUtils;
import br.com.bi.model.Application;
import br.com.bi.model.entity.metadata.CubeLevel;
import br.com.bi.model.entity.metadata.Dimension;
import br.com.bi.model.entity.metadata.Level;
import br.com.bi.model.entity.metadata.Metadata;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 *
 * @author luiz
 */
public class QuerySqlTranslator extends AbstractQueryVisitor {

    private MetadataCache extractedMetadata;
    private br.com.bi.model.entity.metadata.Cube cube;

    @Override
    public void visit(Select node, StringBuilder data) {
        QueryMetadataExtractor extractor = new QueryMetadataExtractor();
        extractor.visit(node, data);

        this.extractedMetadata = extractor.getExtractedMetadata();

        this.cube = Application.getCubeDao().findByName(TranslationUtils.extractName(((SimpleNode) node.jjtGetChild(2)).jjtGetValue().toString()));

        data.append("select ");

        visitChildren(node, data);
    }

    @Override
    public void visit(Cube node, StringBuilder data) {
        // delete last comma generated by axis translation
        data.delete(data.length() - 2, data.length());

        data.append(" from ");

        List<String> tables = new ArrayList<String>();

        tables.add(tableExpression(cube.getSchemaName(), cube.getTableName()));

        for (Level topLevel : topLevels()) {
            for (Level lowerLevel : topLevel.getLowerLevels()) {
                tables.add(tableExpression(lowerLevel.getSchemaName(),
                        lowerLevel.getTableName()));
            }
        }

        for (int i = 0; i < tables.size(); i++) {
            data.append(tables.get(i));

            if (i < tables.size() - 1) {
                data.append(", ");
            }
        }
        
        data.append(" having ");
        
        whereExpression(data);
    }

    @Override
    public void visit(FilterExpression node, StringBuilder data) {
        data.append(" and ");
        visitChildren(node, data);
    }

    @Override
    public void visit(Disjunction node, StringBuilder data) {
        visitOperation(node, "or", data);
    }

    @Override
    public void visit(Conjunction node, StringBuilder data) {
        visitOperation(node, "and", data);
    }

    @Override
    public void visit(Negation node, StringBuilder data) {
        if (data.charAt(data.length() - 1) != ' ') {
            data.append(" not");
        } else {
            data.append("not ");
        }

        visit(node.jjtGetChild(0), data);
    }

    @Override
    public void visit(LevelOrMeasure node, StringBuilder data) {
        br.com.bi.model.entity.metadata.Measure measure = extractedMetadata.getMeasure(node.jjtGetValue().toString());

        if (measure != null) {
            Measure m = new Measure(FilterParserTreeConstants.JJTMEASURE);
            m.jjtSetValue(node.jjtGetValue());

            visit(m, data);
        } else {
            br.com.bi.model.entity.metadata.Level level = extractedMetadata.getLevel(node.jjtGetValue().toString());

            data.append(level.getSchemaName()).append(".").
                    append(level.getTableName()).append(".").
                    append(level.getCodeProperty().getColumnName());
        }
    }

    @Override
    public void visit(Measure node, StringBuilder data) {
        MeasureSqlTranslator translator = new MeasureSqlTranslator(this.cube);

        data.append(translator.translate(node.jjtGetValue().toString()));
    }

    @Override
    public void visit(Filter node, StringBuilder data) {
        FilterSqlTranslator translator = new FilterSqlTranslator(this.cube);
        String filterTranslation = translator.translate(node.jjtGetValue().toString());
        data.append(filterTranslation);
    }

    @Override
    public void visit(Property node, StringBuilder data) {
        br.com.bi.model.entity.metadata.Property property = extractedMetadata.getProperty(node.jjtGetValue().toString());

        data.append(property.getLevel().getSchemaName()).append(".").
                append(property.getLevel().getTableName()).append(".").
                append(property.getColumnName());
    }

    @Override
    public void visit(RelationalOperator node, StringBuilder data) {
        data.append(" ").append(node.jjtGetValue()).append(" ");
    }

    @Override
    public void visit(Date node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(StringLiteral node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(Addition node, StringBuilder data) {
        visitOperation(node, data);
    }

    @Override
    public void visit(Multiplication node, StringBuilder data) {
        visitOperation(node, data);
    }

    @Override
    public void visit(br.com.bi.language.query.Number node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(LevelOrMeasureOrFilter node, StringBuilder data) {
        StringBuilder sb = new StringBuilder();

        br.com.bi.model.entity.metadata.Measure measure = extractedMetadata.getMeasure(node.jjtGetValue().toString());

        if (measure != null) {
            MeasureSqlTranslator translator = new MeasureSqlTranslator(cube);

            sb.append(translator.translate(node.jjtGetValue().toString()));
        } else {
            br.com.bi.model.entity.metadata.Level level = extractedMetadata.getLevel(node.jjtGetValue().toString());

            if (level != null) {
                sb.append(level.getSchemaName()).append(".").
                        append(level.getTableName()).append(".").
                        append(level.getCodeProperty().getColumnName());
            } else {
                br.com.bi.model.entity.metadata.Filter filter = extractedMetadata.getFilter(node.jjtGetValue().toString());

                FilterSqlTranslator translator = new FilterSqlTranslator(cube);

                sb.append("case when ").append(translator.translate(filter.getExpression())).append(" then 1 else 0 end");
            }
        }

        data.append(sb).append(", ");
    }

    private void visitOperation(SimpleNode node, StringBuilder data) {
        visitOperation(node, node.jjtGetValue().toString(), data);
    }

    private void visitOperation(SimpleNode node, String op, StringBuilder data) {
        data.append("(");

        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            visit(node.jjtGetChild(i), data);
            if (i < node.jjtGetNumChildren() - 1) {
                data.append(" ").append(op).append(" ");
            }
        }

        data.append(")");
    }

    // ==========================
    // ====== Utilitários =======
    // ==========================
    /**
     * Retorna os níveis utilizados na consulta que são os mais altos em suas dimensões.
     * @param query
     * @return
     */
    private List<Level> topLevels() {
        Map<Integer, Level> topLevels = new HashMap<Integer, Level>();

        List<Level> levelsPresent = levelsPresent();

        for (Level level : levelsPresent) {
            Dimension dimension = level.getDimension();

            // se o nível está acima do que já está no mapa então ele é um "top level".
            if (!topLevels.containsKey(dimension.getId())
                    || level.getIndice()
                    < topLevels.get(dimension.getId()).getIndice()) {
                topLevels.put(dimension.getId(), level);
            }
        }

        return new ArrayList<Level>(topLevels.values());
    }

    /**
     * Retorna os níveis presentes na consulta, seja explicitamente em um nó, ou indiretamente
     * através de um nó filtro, ou filtro de métrica, ou ainda filtro na consulta.
     * @param query
     * @return
     */
    private List<Level> levelsPresent() {
        List<Level> levels = new ArrayList<Level>();

        for (Entry<String, Metadata> entry : extractedMetadata.getInternalMap().entrySet()) {
            if (entry.getValue() instanceof Level) {
                levels.add((Level) entry.getValue());
            } else if (entry.getValue() instanceof br.com.bi.model.entity.metadata.Property) {
                levels.add(((br.com.bi.model.entity.metadata.Property) entry.getValue()).getLevel());
            }
        }

        return levels;
    }

    /**
     * Retorna a expressão corresponde à referência para uma consulta.
     * Normalmente esta expressão é denotada por "esquema.tabela".
     *
     * @param schema
     * @param table
     * @return
     */
    private String tableExpression(String schema, String table) {
        StringBuilder sb = new StringBuilder();

        sb.append(schema).append(".").append(table);

        return sb.toString();
    }

    /**
     * Retorna uma string do tipo tabela + . + coluna.
     * @param table
     * @param column
     * @return
     */
    public String columnExpression(String table, String column) {
        StringBuilder sb = new StringBuilder();

        sb.append(table).append(".").append(column);

        return sb.toString();
    }

    /**
     * Produz a cláusula WHERE da consulta, baseado nos joins resultantes das referências
     * para os níveis da consulta.
     * @return
     */
    private String whereExpression(StringBuilder data) {
        List<String> joins = new ArrayList<String>();

        List<Level> topLevels = topLevels();

        // do nível mais alto vai descendo e adicionando os joins até chegar o nível
        // mais baixo e assim juntá-lo ao cubo
        for (Level topLevel : topLevels) {
            List<Level> lowerLevels = topLevel.getLowerLevels();

            for (int i = 0; i < lowerLevels.size(); i++) {
                // de duas em duas colunas, coloca o join na lista
                if (i > 0 & (i + 1) % 2 == 0) {
                    String upperColumn = columnExpression(lowerLevels.get(i - 1).getTableName(), lowerLevels.get(i - 1).getCodeProperty().getColumnName());

                    String thisColumn = columnExpression(lowerLevels.get(i).getTableName(), lowerLevels.get(i).getUpperLevelJoinColumn());

                    joins.add(thisColumn + " = " + upperColumn);
                }
            }

            // o nível mais baixo (cujo índice é o maior) é o nível que faz junção com o cubo,
            // e indiretamente liga todos os níveis superiores também.
            Collections.sort(lowerLevels, new Comparator<Level>()   {

                public int compare(Level level1, Level level2) {
                    return Integer.valueOf(level1.getIndice()).compareTo(Integer.valueOf(level2.getIndice()));
                }
            });

            Level lowestLevel = lowerLevels.get(lowerLevels.size() - 1);

            for (CubeLevel level : cube.getCubeLevelList()) {
                if (level.getLevel().getId() == lowestLevel.getId()) {
                    joins.add(columnExpression(cube.getTableName(), level.getJoinColumn()) + " = " + columnExpression(lowestLevel.getTableName(), lowestLevel.getCodeProperty().getColumnName()));
                }
            }
        }

        if (joins.isEmpty()) {
            data.append("1 = 1");
        } else {
            for (int i = 0; i < joins.size(); i++) {
                data.append(joins.get(i));

                if (i < joins.size() - 1) {
                    data.append(" and ");
                }
            }
        }

        return data.toString();
    }
}
