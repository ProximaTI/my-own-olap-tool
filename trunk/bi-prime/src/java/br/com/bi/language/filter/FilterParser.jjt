options 
{ 
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    NODE_PREFIX = ""; 
    MULTI = true;
    VISITOR = true;
    VISITOR_RETURN_TYPE = "void";
    VISITOR_DATA_TYPE = "StringBuilder";
}

PARSER_BEGIN (FilterParser)
package br.com.bi.language.filter;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class FilterParser {

    public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(
              ("[teste] e não [teste] > ((-1 / (100.8 + 2)) * [teste])").getBytes());

        FilterParser parser = new FilterParser(in);
        
        try {
            SimpleNode node = parser.filterExpression();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
    }
}
PARSER_END (FilterParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "não" >
| < AND: "e" >
| < OR: "ou" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LBRA: "[" >
| < RBRA: "]" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

SimpleNode filterExpression() #FilterExpression :
{
}
{
    disjunction() <EOF>

    {
        return jjtThis;
    }
}

void disjunction() #Disjunction(>1) :
{
}
{
    ( conjunction() ( <OR> conjunction() )* ) 
}

void conjunction() #Conjunction(>1) : 
{
}
{
    ( term() ( <AND> term() )* )
}

void term() :
{
}
{
    atom() | negation() 
}

void atom() :
{
}
{
    comparison() | "(" filterExpression() ")"
}

void negation() #Negation :
{
}
{
    <NOT> ( term() ) 
}

void comparison() #Comparison : 
{
}
{
    LOOKAHEAD(2)

    levelOrMeasure() relationalOperator() operating() | ( LOOKAHEAD(2) property() relationalOperator() operating() | filter() )
    
    // just a filter or a comparison involving a level or some property are valid comparisons
} 

void measure() #Measure : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void levelOrMeasure() #LevelOrMeasure : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void filter() #Filter : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void property() #Property :
{
    Token t;
    String property;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        property = t.image;
    }

    <DOT> 

    t = <METADATA_OBJECT_NAME>

    {
        property += "." + t.image;

        jjtThis.value = property;
    }
}

void relationalOperator() #RelationalOperator :
{
    Token t;
}
{
    t = <RELATIONAL_OPERATOR> 

    {
        jjtThis.value = t.image;
    }
}

void operating() :
{
}
{
    date() | stringLiteral() | arithmeticExpression() #ArithmeticExpression 
}

void date() #Date :
{
    Token t;
}
{
    t = <DATE>

    {
        jjtThis.value = t.image;
    }
}

void stringLiteral() #StringLiteral :
{
    Token t;
}
{
    t = <STRING_LITERAL>

    {
        jjtThis.value = t.image;
    }
}

void arithmeticExpression() : 
{
}
{
    additiveExpression() 
}

void additiveExpression() #Addition(>1) :
{
    String op = null;
}
{
    ( multiplicativeExpression() ( ( op = additiveOperator() ) multiplicativeExpression() )* )

    {
        jjtThis.value = op;
    }
}

String additiveOperator() :
{
    Token t;
}
{
    ( t = <PLUS> | t = <MINUS> )

    {
        return t.image;
    }
}

void multiplicativeExpression() #Multiplication(>1) :
{
    String op = null;
}
{
    ( arithmeticAtom() ( ( op = multiplicativeOperator() ) arithmeticAtom() )* )

    {
        jjtThis.value = op;
    }
}

String multiplicativeOperator() :
{
    Token t;
}
{
    ( t = <MULT> | t = <DIV> )

    {
        return t.image;
    }
}

void arithmeticAtom() :
{
}
{
    "(" arithmeticExpression() ")" | measure() | number()
}

void number() #Number :
{
    Token minus = null;
    Token number;
}
{
    [ minus = <MINUS> ]

    ( number = <INTEGER_LITERAL> | number = <FLOATING_POINT_LITERAL> )

    {
        jjtThis.value = minus == null ? number.image : minus.image + number.image;
    }
}
