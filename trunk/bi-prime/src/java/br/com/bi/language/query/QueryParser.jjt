options 
{ 
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    NODE_PREFIX = ""; 
    MULTI = true;
}

PARSER_BEGIN(QueryParser)
package br.com.bi.language.query;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class QueryParser {

    private boolean rows = false;
    private boolean columns = false;

    public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(
              ("selecione {[teste], ([teste], [teste])}"
                + " nas colunas, [teste] nas linhas "
                + "do cubo [teste] "
                + "onde [teste] e não [teste] > ((-1 / (100.8 + 2)) * [teste])").getBytes());

        QueryParser parser = new QueryParser(in);
        
        try {
            SimpleNode node = parser.instruction();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
    }
}
PARSER_END(QueryParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "não" >
| < AND: "e" >
| < OR: "ou" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LBRA: "[" >
| < RBRA: "]" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < SELECT: "selecione" >
| < ON: "nas" >
| < ROWS: "linhas" >
| < COLUMNS: "colunas" >
| < FROM: "do" >
| < CUBE: "cubo" >
| < WHERE: "onde" >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

SimpleNode instruction() #Instruction: 
{
}
{
    ( select() )

    {
        return jjtThis;
    }
}

void select() #Select :
{
}
{
    <SELECT>  axis() "," axis() <FROM> <CUBE> cube() <WHERE> filterExpression() <EOF>
}

void axis() #Axis :
{
    String axis;
} 
{
    set() <ON>  ( axis = rows() | axis = columns() )
    
    { 
        jjtThis.value = axis; 
    }
}

String rows() : 
{
} 
{ 
    { 
        if (rows) 
            throw new ParseException("O eixo das linhas foi duplicado"); 
        else 
            rows = true;
    }

    <ROWS>

    {
        return "ROWS";
    }
}

String columns() : 
{
} 
{ 
    {
        if (columns) 
            throw new ParseException("O eixo das colunas foi duplicado"); 
        else 
            columns = true;
    }

    <COLUMNS>

    {
        return "COLUMNS";
    }
}

void set() : 
{
}
{
    node() | "{" node() ( "," node() )+ "}" 
}

void node() :
{
}
{
    metadataObject() | crossJoin() #Crossjoin 
}

void metadataObject() #MetadataObject :
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void crossJoin() :
{
}
{
    "(" set() "," set() ")" 
}

void cube() #Cube :
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME> 
    
    {
        jjtThis.value = t.image;
    }
}
 
void filterExpression() #FilterExpression :
{
}
{
    disjunction() 
}

void disjunction() #Disjunction(>1) :
{
}
{
    ( conjunction() ( <OR> conjunction() )* ) 
}

void conjunction() #Conjunction(>1) : 
{
}
{
    ( term() ( <AND> term() )* )
}

void term() :
{
}
{
    atom() | negation() 
}

void atom() :
{
}
{
    comparison() | "(" filter() ")" 
}

void negation() #Negation :
{
}
{
    <NOT> ( term() ) 
}

void comparison() : 
{
}
{
    LOOKAHEAD(2)

    level() relationalOperator() operating() | ( LOOKAHEAD(2) property() relationalOperator() operating() | filter() )
    
    // just a filter or a comparison involving a level or some property are valid comparisons
} 

void level() #Level : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void measure() #Measure : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void filter() #Filter : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void property() #Property :
{
    Token t;
    String property;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        property = t.image;
    }

    <DOT> 

    t = <METADATA_OBJECT_NAME>

    {
        property += "." + t.image;

        jjtThis.value = t.image;
    }
}

void relationalOperator() #RelationalOperator :
{
    Token t;
}
{
    t = <RELATIONAL_OPERATOR> 

    {
        jjtThis.value = t.image;
    }
}

void operating() :
{
}
{
    date() | stringLiteral() | arithmeticExpression() #ArithmeticExpression 
}

void date() #Date :
{
    Token t;
}
{
    t = <DATE>

    {
        jjtThis.value = t.image;
    }
}

void stringLiteral() #StringLiteral :
{
    Token t;
}
{
    t = <STRING_LITERAL>

    {
        jjtThis.value = t.image;
    }
}

void arithmeticExpression() : 
{
}
{
    additiveExpression() 
}

void additiveExpression() #Addition(>1) :
{
    String op = null;
}
{
    ( multiplicativeExpression() ( ( op = additiveOperator() ) multiplicativeExpression() )* )

    {
        jjtThis.value = op;
    }
}

String additiveOperator() :
{
    Token t;
}
{
    ( t = <PLUS> | t = <MINUS> )

    {
        return t.image;
    }
}

void multiplicativeExpression() #Multiplication(>1) :
{
    String op = null;
}
{
    ( arithmeticAtom() ( ( op = multiplicativeOperator() ) arithmeticAtom() )* )

    {
        jjtThis.value = op;
    }
}

String multiplicativeOperator() :
{
    Token t;
}
{
    ( t = <MULT> | t = <DIV> )

    {
        return t.image;
    }
}

void arithmeticAtom() :
{
}
{
    "(" arithmeticExpression() ")" | measure() | number()
}

void number() #Number :
{
    Token minus = null;
    Token number;
}
{
    [ minus = <MINUS> ]

    ( number = <INTEGER_LITERAL> | number = <FLOATING_POINT_LITERAL> )

    {
        jjtThis.value = minus == null ? number.image : minus.image + number.image;
    }
}
