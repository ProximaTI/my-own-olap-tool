options 
{ 
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    NODE_PREFIX = ""; 
    MULTI = true;
    VISITOR = true;
    VISITOR_RETURN_TYPE = "void";
    VISITOR_DATA_TYPE = "StringBuilder";
    NODE_USES_PARSER = false;
}

PARSER_BEGIN(QueryParser)
package br.com.bi.olapql.language.query;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class QueryParser {
    private boolean rows = false;
    private boolean columns = false;

    public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(
("selecione {[teste], ([teste], [teste])} nas colunas, [teste] nas linhas do cubo [teste] onde [teste] e não [teste] > ((-1 / (100.8 + 2)) * [teste])").getBytes());

        QueryParser parser = new QueryParser(in);
        
        try {
            SimpleNode node = parser.instruction();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
    }

    private void fixChildren(Node node) {
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            node.jjtGetChild(i).jjtSetParent(node);

            fixChildren(node.jjtGetChild(i));
        }
    }
}
PARSER_END(QueryParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "não" >
| < AND: "e" >
| < OR: "ou" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LBRA: "[" >
| < RBRA: "]" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < SELECT: "selecione" >
| < ON: "nas" >
| < ROWS: "linhas" >
| < COLUMNS: "colunas" >
| < FROM: "do" >
| < CUBE: "cubo" >
| < WHERE: "onde" >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

SimpleNode instruction() #Instruction: 
{
}
{
    ( select() )

    {
        return jjtThis;
    }
}

void select() #Select :
{
}
{
    <SELECT>  axis() "," axis() <FROM> <CUBE> cube() [ <WHERE> filterExpression() ] <EOF>
}

void axis() #Axis :
{
    java.util.List<SimpleNode> nodes = new java.util.ArrayList<SimpleNode>();
    String axis;
} 
{
    ( set(nodes) <ON>  ( axis = rows() | axis = columns() ) )
    
    {
        // desconsidera os children adicionados pelo jjtree através do método closeNodeScope
        jjtThis.children = null;

        for (SimpleNode node: nodes) {
            jjtThis.jjtAddChild(node, jjtThis.jjtGetNumChildren());
            node.jjtSetParent(jjtThis);
        }

        fixChildren(jjtThis);

        jjtThis.value = axis; 
    }
}

String rows() : 
{
} 
{ 
    { 
        if (rows) 
            throw new ParseException("O eixo das linhas foi duplicado"); 
        else 
            rows = true;
    }

    <ROWS>

    {
        return "ROWS";
    }
}

String columns() : 
{
} 
{ 
    {
        if (columns) 
            throw new ParseException("O eixo das colunas foi duplicado"); 
        else 
            columns = true;
    }

    <COLUMNS>

    {
        return "COLUMNS";
    }
}

void set(java.util.List<SimpleNode> nodes) : 
{
    SimpleNode node = null;
}
{
    ( 
        node = node() { nodes.add(node); } | 

        (
            LOOKAHEAD(3) "{" node = node() { nodes.add(node); } ( "," set(nodes) )* "}" | 

            "{" set(nodes) "}" 
        ) 
    )
}

SimpleNode node() :
{
    SimpleNode node;
}
{
    ( node = metadataObject() | node = crossJoin() )

    {
        return node;
    }
}

SimpleNode metadataObject() :
{
    SimpleNode node = null;
}
{
    ( LOOKAHEAD(2)

    node = propertyNode() | node = levelOrMeasureOrFilter() )

    {
        return node;
    }
}

SimpleNode levelOrMeasureOrFilter() #LevelOrMeasureOrFilter : 
{
    Token t;
}
{

    ( t = <METADATA_OBJECT_NAME> )

    {
        jjtThis.value = t.image;
        return jjtThis;
    }
}

SimpleNode propertyNode() #PropertyNode :
{
    Token t;
    String property;
}
{
    ( t = <METADATA_OBJECT_NAME>

    {
        property = t.image;
    }

    <DOT> 

    t = <METADATA_OBJECT_NAME> )

    {
        property += "." + t.image;

        jjtThis.value = property;

        return jjtThis;
    }
}

SimpleNode crossJoin() :
{
    SimpleNode firstArgument;
    java.util.List<SimpleNode> secondArgument = new java.util.ArrayList<SimpleNode>();
}
{
    ( "(" firstArgument = metadataObject() "," set(secondArgument) ")" )

    {
        for (SimpleNode node: secondArgument) {
            firstArgument.jjtAddChild(node, firstArgument.jjtGetNumChildren());
            node.jjtSetParent(firstArgument);
        }

        return firstArgument;
    }
}

void cube() #Cube :
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME> 
    
    {
        jjtThis.value = t.image;
    }
}
 
void filterExpression() #FilterExpression :
{
}
{
    disjunction() 
}

void disjunction() #Disjunction(>1) :
{
}
{
    ( conjunction() ( <OR> conjunction() )* ) 
}

void conjunction() #Conjunction(>1) : 
{
}
{
    ( term() ( <AND> term() )* )
}

void term() :
{
}
{
    atom() | negation() 
}

void atom() :
{
}
{
    ( LOOKAHEAD(2) comparison() | filter() ) | "(" filterExpression() ")" 
}

void negation() #Negation :
{
}
{
    <NOT> ( term() ) 
}

void comparison() #Comparison : 
{
}
{
    property() relationalOperator() operating()
} 

void level() #Level : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

void filter() #Filter : 
{
    Token t;
}
{
    t = <METADATA_OBJECT_NAME>

    {
        jjtThis.value = t.image;
    }
}

SimpleNode property() #Property :
{
    Token t;
    String property;
}
{
    ( t = <METADATA_OBJECT_NAME>

    {
        property = t.image;
    }

    <DOT> 

    t = <METADATA_OBJECT_NAME> )

    {
        property += "." + t.image;

        jjtThis.value = property;

        return jjtThis;
    }
}

void relationalOperator() #RelationalOperator :
{
    Token t;
}
{
    t = <RELATIONAL_OPERATOR> 

    {
        jjtThis.value = t.image;
    }
}

void operating() :
{
}
{
    date() | stringLiteral() | arithmeticExpression() #ArithmeticExpression 
}

void date() #Date :
{
    Token t;
}
{
    t = <DATE>

    {
        jjtThis.value = t.image;
    }
}

void stringLiteral() #StringLiteral :
{
    Token t;
}
{
    t = <STRING_LITERAL>

    {
        jjtThis.value = t.image;
    }
}

void arithmeticExpression() : 
{
}
{
    additiveExpression() 
}

void additiveExpression() #Addition(>1) :
{
    String op = null;
}
{
    ( multiplicativeExpression() ( ( op = additiveOperator() ) multiplicativeExpression() )* )

    {
        jjtThis.value = op;
    }
}

String additiveOperator() :
{
    Token t;
}
{
    ( t = <PLUS> | t = <MINUS> )

    {
        return t.image;
    }
}

void multiplicativeExpression() #Multiplication(>1) :
{
    String op = null;
}
{
    ( arithmeticAtom() ( ( op = multiplicativeOperator() ) arithmeticAtom() )* )

    {
        jjtThis.value = op;
    }
}

String multiplicativeOperator() :
{
    Token t;
}
{
    ( t = <MULT> | t = <DIV> )

    {
        return t.image;
    }
}

void arithmeticAtom() :
{
}
{
    "(" arithmeticExpression() ")" | level() | number()
}

void number() #Number :
{
    Token minus = null;
    Token number;
}
{
    [ minus = <MINUS> ]

    ( number = <INTEGER_LITERAL> | number = <FLOATING_POINT_LITERAL> )

    {
        jjtThis.value = minus == null ? number.image : minus.image + number.image;
    }
}
