options 
{ 
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    NODE_PREFIX = ""; 
    MULTI = true;
    VISITOR = true;
    VISITOR_RETURN_TYPE = "void";
    VISITOR_DATA_TYPE = "StringBuilder";
}

PARSER_BEGIN (FilterParser)
package br.com.bi.olapql.language.filter;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class FilterParser {

    public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(
              ("[teste] e não [teste] > ((-1 / (100.8 + 2)) * [teste])").getBytes());

        FilterParser parser = new FilterParser(in);
        
        try {
            SimpleNode node = parser.filterExpression();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
    }
}
PARSER_END (FilterParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [ IGNORE_CASE ] :
{
   < RELATIONAL_OPERATOR :
      ">"
   |  "<"
   |  ">="
   |  "<="
   |  "="
   |  "<>" >
|  < NOT : "não" >
|  < AND : "e" >
|  < OR : "ou" >
|  < DOT : "." >
|  < PLUS : "+" >
|  < MINUS : "-" >
|  < MULT : "*" >
|  < DIV : "/" >
|  < LBRA : "[" >
|  < RBRA : "]" >
|  < LPAREN : "(" >
|  < RPAREN : ")" >
|  < COMMA : "," >
|  < LBRACE : "{" >
|  < RBRACE : "}" >
|  < DATE :
      (
         ([ "0"-"9" ])+ "/" ([ "0"-"9" ])+ "/" ([ "0"-"9" ])+
      ) >
|  < IN : "pertence" >
|  < LIKE : "contém" >
|  < STARTS_WITH : "começa com" >
|  < ENDS_WITH : "termina com" >
|  < METADATA_OBJECT_NAME : < LBRA > (~[ "[", "]" ])+ < RBRA > >
|  < FLOATING_POINT_LITERAL :
      ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
   |  "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
   |  ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?
   |  ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ] >
|  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
|  < INTEGER_LITERAL : [ "0"-"9" ] ([ "0"-"9" ])* >
|  < STRING_LITERAL : "\"" (< CHAR >)* "\"" >
|  < #CHAR :
      (
         ~[ "\"" ]
      |  "\\" ([ "n", "r", "\\", "\'", "\"" ])
      ) >
}


SimpleNode filterExpression() #FilterExpression:
{}
{
   orCondition() <EOF>

    {
        return jjtThis;
    }
}

void orCondition() #OrCondition(>1)
:
{}
{
   (
      andCondition()
      (
         < OR > andCondition()
      )*
   )
}

void andCondition() #AndCondition(>1)
:
{}
{
   (
      condition()
      (
         < AND > condition()
      )*
   )
}

void condition() #Condition(>1)
:
{}
{
   (
      negation()
   |
      (
         LOOKAHEAD(2)
         operand() conditionRightHandSide()
      |  filter()
      )
   |  < LPAREN > filterExpression() < RPAREN >
   )
}

void negation() #Negation :
{}
{
   < NOT >
   (
      condition()
   )
}

void operand() :
{}
{
   summand()
}

void conditionRightHandSide() :
{}
{
   compare() operand()
|  inExpression()
|  likeExpression()
|  startsWithExpression()
|  endsWithExpression()
}

void inExpression() #InExpression :
{}
{
   < IN > < LPAREN > value()
   (
      < COMMA > value()
   )*
   < RPAREN >
}

void likeExpression() #LikeExpression :
{}
{
   < LIKE > operand()
}

void startsWithExpression() #StartsWithExpression :
{}
{
   < STARTS_WITH > operand()
}

void endsWithExpression() #EndsWithExpression :
{}
{
   < ENDS_WITH > operand()
}

void compare() #Compare :
{
   Token t;
}
{
   t = < RELATIONAL_OPERATOR >
   {
      jjtThis.value = t.image;
   }
}

void summand() #AdditiveExpression(>1)
:
{
   String op = null;
}
{
   (
      factor()
      (
         (
            op = additiveOperator()
         )
         factor()
      )*
   )
   {
      jjtThis.value = op;
   }
}

String additiveOperator() :
{
   Token t;
}
{
   (
      t = < PLUS >
   |  t = < MINUS >
   )
   {
      return t.image;
   }
}

void factor() #MultiplicativeExpression(>1)
:
{
   String op = null;
}
{
   (
      term()
      (
         (
            op = multiplicativeOperator()
         )
         term()
      )*
   )
   {
      jjtThis.value = op;
   }
}

String multiplicativeOperator() :
{
   Token t;
}
{
   (
      t = < MULT >
   |  t = < DIV >
   )
   {
      return t.image;
   }
}

void term() :
{}
{
   value()
|  property()
}

void value() :
{}
{
   numberLiteral()
|  dateLiteral()
|  stringLiteral()
}

/* **************************** */
/* ********* LITERALS ********* */
/* **************************** */
void numberLiteral() #NumberLiteral :
{
   Token minus = null;
   Token number;
}
{
   [ minus = < MINUS > ]
   (
      number = < INTEGER_LITERAL >
   |  number = < FLOATING_POINT_LITERAL >
   )
   {
      jjtThis.value = minus == null ? number.image : minus.image + number.image;
   }
}

void dateLiteral() #DateLiteral :
{
   Token t;
}
{
   t = < DATE >
   {
      jjtThis.value = t.image;
   }
}

void stringLiteral() #StringLiteral :
{
   Token t;
}
{
   t = < STRING_LITERAL >
   {
      jjtThis.value = t.image;
   }
}

void filter() #Filter :
{
   Token t;
}
{
   t = < METADATA_OBJECT_NAME >
   {
      jjtThis.value = t.image;
   }
}

SimpleNode property() #Property :
{
   Token t;
   String property;
}
{
   (t = < METADATA_OBJECT_NAME >
   {
      property = t.image;
   }
   < DOT > t = < METADATA_OBJECT_NAME >)
   {
      property += "." + t.image;
      jjtThis.value = property;
      return jjtThis;
   }
}
