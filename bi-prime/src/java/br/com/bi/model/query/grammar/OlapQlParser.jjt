PARSER_BEGIN(OlapQlParser)
package br.com.bi.model.query.grammar;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class OlapQlParser {
  public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(("select [teste];([teste], [teste])"
                + " on columns, [teste] on rows "
                + "from [teste] "
                + "where not [teste] > (1 + 2 * 5)").getBytes());

        OlapQlParser parser = new OlapQlParser(in);
        try {
            SimpleNode node = parser.query();
            node.dump(" ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
  }
}
PARSER_END(OlapQlParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LPAR: "(" >
| < RPAR: ")" >
| < LBRA: "[" >
| < RBRA: "]" >
| < COMMA: "," >
| < NODE_SEPARATOR: ";" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < SELECT: "select" >
| < ON: "on" >
| < ROWS: "rows" >
| < COLUMNS: "columns" >
| < FROM: "from" >
| < WHERE: "where" >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

/* ====================== */
/* = Regras de produção = */
/* ====================== */

SimpleNode query() : 
{}
{
    <SELECT> yAxis() <ON> <COLUMNS> <COMMA> xAxis() <ON> <ROWS> <FROM> cube() <WHERE> filterExpression() <EOF> 
    
    {
        return jjtThis;
    }
}

void yAxis()      : {} { nodeExp() }

void xAxis()      : {} { nodeExp() }

void nodeExp()    : {} { node() ( <NODE_SEPARATOR> node() )* }

void node()       : {} { cubeMetadataNode() | crossJoin() }

// Um metadado pode ser um nível (quando ocorrer <METADATA_OBJECT_NAME> <DOT> <METADATA_OBJECT_NAME>), 
// um filtro, ou uma métrica (quando apenas <METADATA_OBJECT_NAME>). 
void cubeMetadataNode() : {} { <METADATA_OBJECT_NAME> [ <DOT> <METADATA_OBJECT_NAME> ] }

void crossJoin()        : {} { <LPAR> nodeExp() <COMMA> nodeExp() <RPAR> }

void cube()             : {} { <METADATA_OBJECT_NAME> }

/* ===================== */
/* = filter expression = */
/* ===================== */

void filterExpression() : {} { disjunction() }

void disjunction()      : {} { conjunction() ( <OR> conjunction() )* }

void conjunction()      : {} { term() ( <AND> term() )* }

void term()             : {} { atom()| negation() }

void atom()             : {} { comparison() | <LPAR> filterExpression() <RPAR> }

void negation()         : {} { <NOT> term() }

// O segundo caso desta regra de produção ocorre um metadado e eventualmente um operador relacional e um operando.
// Se ocorrer apenas um metadado, então este deve ser um filtro, senão é uma métrica seguida de um operador e um operando.
void comparison()               : {} { <METADATA_OBJECT_NAME> [ <DOT> <METADATA_OBJECT_NAME> <DOT> <METADATA_OBJECT_NAME> ] [ <RELATIONAL_OPERATOR> operating() ] } 

void operating()                : {} { <DATE> | <STRING_LITERAL> | arithmeticExpression() }

void arithmeticExpression()     : {} { additiveExpression() }

void additiveExpression()       : {} { multiplicativeExpression() ( ( <PLUS> | <MINUS> ) multiplicativeExpression() )* }

void multiplicativeExpression() : {} { unaryExpression() ( ( <MULT> | <DIV> ) unaryExpression() )* }

void unaryExpression()          : {} { <LPAR> arithmeticExpression() <RPAR> | <METADATA_OBJECT_NAME> | number() }

void number()                   : {} { [ <MINUS> ] ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> )  }
