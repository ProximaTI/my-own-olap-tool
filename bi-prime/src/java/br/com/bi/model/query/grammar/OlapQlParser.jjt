options 
{ 
    STATIC = false;
    NODE_FACTORY="OlapQlParser";
    NODE_DEFAULT_VOID = true;
    NODE_PREFIX = ""; 
}

PARSER_BEGIN(OlapQlParser)
package br.com.bi.model.query.grammar;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class OlapQlParser {

    private boolean rows = false;
    private boolean columns = false;

    public static void main(String args[]) {
        InputStream in = new ByteArrayInputStream(
              ("selecione {[teste], ([teste], [teste])}"
                + " nas colunas, [teste] nas linhas "
                + "do cubo [teste] "
                + "onde [teste] = 1 ou [teste] e não [teste] > (1 / 1 + 2 * [teste])").getBytes());

        OlapQlParser parser = new OlapQlParser(in);
        
        try {
            SimpleNode node = parser.query();
            node.dump("   ");
        } catch (ParseException ex) {
            ex.printStackTrace();
        }
    }

    public static SimpleNode jjtCreate(int id) {
        return new OlapQlNode(id);
    }

    static class OlapQlNode extends SimpleNode {

        OlapQlNode(int i) {
            super(i);
        }

        @Override
        public String toString() {
            if (value != null)
                return OlapQlParserTreeConstants.jjtNodeName[id] + "-" + value;
            else
                return OlapQlParserTreeConstants.jjtNodeName[id];
        }
    }
}
PARSER_END(OlapQlParser)

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN [IGNORE_CASE] :
{
  < RELATIONAL_OPERATOR: ">" | "<" | ">=" | "<=" | "=" >
| < NOT: "não" >
| < AND: "e" >
| < OR: "ou" >
| < DOT: "." >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < LBRA: "[" >
| < RBRA: "]" >
| < DATE: ((["0"-"9"])+ "/" (["0"-"9"])+ "/" (["0"-"9"])+) >
| < SELECT: "selecione" >
| < ON: "nas" >
| < ROWS: "linhas" >
| < COLUMNS: "colunas" >
| < FROM: "do" >
| < CUBE: "cubo" >
| < WHERE: "onde" >
| < METADATA_OBJECT_NAME: <LBRA> (~["[","]"])+ <RBRA> >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? 
                             | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? 
                             | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                             | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
| < STRING_LITERAL: "\"" (<CHAR>)* "\"" > 
| < #CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
}

SimpleNode query() #Query : 
{
}
{
    <SELECT> axisSpecification() "," axisSpecification() <FROM> <CUBE> cube() <WHERE> filterExpression() <EOF> 
    
    {
        return jjtThis;
    }
}

void axisSpecification() #Axis :
{
    String axis;
} 
{
    set() <ON>  ( axis = rows() | axis = columns() )
    
    { jjtThis.value = axis; }
}

String rows() : 
{
} 
{ 
    { 
        if (rows) 
            throw new ParseException("O eixo das linhas foi duplicado"); 
        else 
            rows = true;
    }

    <ROWS>

    {
        return "ROWS";
    }
}

String columns() : 
{
} 
{ 
    {
        if (columns) 
            throw new ParseException("O eixo das colunas foi duplicado"); 
        else 
            columns = true;
    }

    <COLUMNS>

    {
        return "COLUMNS";
    }
}

void set() : 
{
}
{
    node() | "{" node() ( "," node() )+ "}" 
}

void node() :
{
}
{
    <METADATA_OBJECT_NAME> #MetadataObject | crossJoin() #Crossjoin 
}

void crossJoin() :
{
}
{
    "(" set() #FirstSet "," set() #SecondSet ")" 
}

void cube() #Cube :
{
}
{
    <METADATA_OBJECT_NAME> 
}
 
void filterExpression() #Filter :
{
}
{
    disjunction() 
}

void disjunction() :
{
}
{
    ( conjunction() ( <OR> conjunction() )* ) #Disjunction(>1)
}

void conjunction() : 
{
}
{
    ( term() ( <AND> term() )* ) #Conjunction(>1)
}

void term() :
{
}
{
    atom() | negation() 
}

void atom() :
{
}
{
    comparison() | "(" filterExpression() ")" 
}

void negation() #Negation :
{
}
{
    <NOT> ( term() ) 
}

void comparison() #Comparison : 
{
}
{
    ( <METADATA_OBJECT_NAME> ) #MetadataObject [ <DOT> <METADATA_OBJECT_NAME> ] [ <RELATIONAL_OPERATOR> #RelationalOperator operating() ]  // [measure] > 1 or [level].[property] = "foo"
} 

void operating() :
{
}
{
    <DATE> #Date | <STRING_LITERAL> #StringLiteral | arithmeticExpression() #ArithmeticExpression 
}

void arithmeticExpression() : 
{
}
{
    additiveExpression() 
}

void additiveExpression() :
{
}
{
    ( multiplicativeExpression() ( ( <PLUS> | <MINUS> ) multiplicativeExpression() )* ) #Addition(>1)
}

void multiplicativeExpression() :
{
}
{
    ( arithmeticAtom() ( ( <MULT> | <DIV> ) arithmeticAtom() )* ) #Multiplication(>1)
}

void arithmeticAtom() :
{
}
{
    "(" arithmeticExpression() ")" | <METADATA_OBJECT_NAME> #MetadataObject | number()
}

void number() #Number :
{
}
{
    [ <MINUS> ] ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> ) 
}
