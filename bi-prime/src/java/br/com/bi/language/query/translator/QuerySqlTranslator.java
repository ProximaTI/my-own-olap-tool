/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package br.com.bi.language.query.translator;

import br.com.bi.language.filter.translator.FilterSqlTranslator;
import br.com.bi.language.measure.translator.MeasureSqlTranslator;
import br.com.bi.language.query.Addition;
import br.com.bi.language.query.Conjunction;
import br.com.bi.language.query.Cube;
import br.com.bi.language.query.Date;
import br.com.bi.language.query.Disjunction;
import br.com.bi.language.query.Filter;
import br.com.bi.language.query.FilterExpression;
import br.com.bi.language.query.LevelOrMeasureOrFilter;
import br.com.bi.language.query.Multiplication;
import br.com.bi.language.query.Negation;
import br.com.bi.language.query.Property;
import br.com.bi.language.query.RelationalOperator;
import br.com.bi.language.query.Select;
import br.com.bi.language.query.SimpleNode;
import br.com.bi.language.query.StringLiteral;
import br.com.bi.language.utils.MetadataCache;
import br.com.bi.language.utils.TranslationUtils;
import br.com.bi.model.Application;
import br.com.bi.model.entity.metadata.CubeLevel;
import br.com.bi.model.entity.metadata.Level;
import br.com.bi.model.entity.metadata.Metadata;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

/**
 *
 * @author luiz
 */
public class QuerySqlTranslator extends AbstractQueryVisitor {

    private MetadataCache extractedMetadata;
    private br.com.bi.model.entity.metadata.Cube cube;

    @Override
    public void visit(Select node, StringBuilder data) {
        QueryMetadataExtractor extractor = new QueryMetadataExtractor();
        extractor.visit(node, data);

        this.extractedMetadata = extractor.getAllReferencedMetadata();

        this.cube = Application.getCubeDao().findByName(TranslationUtils.extractName(((SimpleNode) node.jjtGetChild(2)).jjtGetValue().toString()));

        data.append("select ");

        visitChildren(node, data);

        // TODO ordenar estes grupos de acordo com a disposição deles nos eixos
        
        if (!extractor.getAddedToAxis().getInternalMap().isEmpty()) {

            StringBuilder groupBy = new StringBuilder();

            for (Entry<String, Metadata> entry : extractedMetadata.getInternalMap().entrySet()) {
                if (entry.getValue() instanceof Level) {
                    groupBy.append(translateLevel((Level) entry.getValue())).append(", ");
                } else if (entry.getValue() instanceof br.com.bi.model.entity.metadata.Property) {
                    groupBy.append(translateProperty((br.com.bi.model.entity.metadata.Property) entry.getValue())).append(", ");
                }
            }

            if (groupBy.length() > 0) {
                groupBy.delete(groupBy.length() - 2, groupBy.length());

                data.append(" group by ").append(groupBy);
            }
        }
    }

    @Override
    public void visit(Cube node, StringBuilder data) {
        // delete last comma generated by axis translation
        data.delete(data.length() - 2, data.length());

        data.append(" from ");

        Set<String> tables = new HashSet<String>();

        tables.add(TranslationUtils.tableExpression(cube.getSchemaName(), cube.getTableName()));

        for (Level level : levelsPresent()) {
            for (Level lowerLevel : level.getLowerLevels()) {
                tables.add(TranslationUtils.tableExpression(lowerLevel.getSchemaName(), lowerLevel.getTableName()));
            }
        }

        for (String table : tables) {
            data.append(table).append(", ");
        }

        if (!tables.isEmpty()) {
            data.delete(data.length() - 2, data.length());
        }

        data.append(" where ");

        whereExpression(data);
    }

    @Override
    public void visit(FilterExpression node, StringBuilder data) {
        data.append(" and ");
        visitChildren(node, data);
    }

    @Override
    public void visit(Disjunction node, StringBuilder data) {
        visitOperation(node, "or", data);
    }

    @Override
    public void visit(Conjunction node, StringBuilder data) {
        visitOperation(node, "and", data);
    }

    @Override
    public void visit(Negation node, StringBuilder data) {
        if (data.charAt(data.length() - 1) != ' ') {
            data.append(" not");
        } else {
            data.append("not ");
        }

        visit(node.jjtGetChild(0), data);
    }

    @Override
    public void visit(br.com.bi.language.query.Level node, StringBuilder data) {
        br.com.bi.model.entity.metadata.Level level = extractedMetadata.getLevel(node.jjtGetValue().toString());

        data.append(translateLevel(level));
    }

    @Override
    public void visit(Filter node, StringBuilder data) {
        FilterSqlTranslator translator = new FilterSqlTranslator(this.cube);
        String filterTranslation = translator.translate(node.jjtGetValue().toString());
        data.append(filterTranslation);
    }

    @Override
    public void visit(Property node, StringBuilder data) {
        br.com.bi.model.entity.metadata.Property property = extractedMetadata.getProperty(node.jjtGetValue().toString());

        data.append(translateProperty(property));
        
        data.append(", ");
    }

    @Override
    public void visit(RelationalOperator node, StringBuilder data) {
        data.append(" ").append(node.jjtGetValue()).append(" ");
    }

    @Override
    public void visit(Date node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(StringLiteral node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(Addition node, StringBuilder data) {
        visitOperation(node, data);
    }

    @Override
    public void visit(Multiplication node, StringBuilder data) {
        visitOperation(node, data);
    }

    @Override
    public void visit(br.com.bi.language.query.Number node, StringBuilder data) {
        data.append(node.jjtGetValue());
    }

    @Override
    public void visit(LevelOrMeasureOrFilter node, StringBuilder data) {
        StringBuilder sb = new StringBuilder();

        br.com.bi.model.entity.metadata.Measure measure = extractedMetadata.getMeasure(node.jjtGetValue().toString());

        if (measure != null) {
            MeasureSqlTranslator translator = new MeasureSqlTranslator(cube);

            sb.append(translator.translate(node.jjtGetValue().toString()));
        } else {
            br.com.bi.model.entity.metadata.Level level = extractedMetadata.getLevel(node.jjtGetValue().toString());

            if (level != null) {
                data.append(TranslationUtils.columnExpression(level.getTableName(), level.getCodeProperty().getColumnName()));
            } else {
                br.com.bi.model.entity.metadata.Filter filter = extractedMetadata.getFilter(node.jjtGetValue().toString());

                FilterSqlTranslator translator = new FilterSqlTranslator(cube);

                sb.append("case when ").append(translator.translate(filter.getExpression())).append(" then 1 else 0 end");
            }
        }

        data.append(sb).append(", ");
    }

    private void visitOperation(SimpleNode node, StringBuilder data) {
        visitOperation(node, node.jjtGetValue().toString(), data);
    }

    private void visitOperation(SimpleNode node, String op, StringBuilder data) {
        data.append("(");

        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            visit(node.jjtGetChild(i), data);
            if (i < node.jjtGetNumChildren() - 1) {
                data.append(" ").append(op).append(" ");
            }
        }

        data.append(")");
    }

    // ==========================
    // ====== Utilitários =======
    // ==========================
    /**
     * Retorna os níveis presentes na consulta, seja explicitamente em um nó, ou indiretamente
     * através de um nó filtro, ou filtro de métrica, ou ainda filtro na consulta.
     * @param query
     * @return
     */
    private List<Level> levelsPresent() {
        List<Level> levels = new ArrayList<Level>();

        for (Entry<String, Metadata> entry : extractedMetadata.getInternalMap().entrySet()) {
            if (entry.getValue() instanceof Level) {
                levels.add((Level) entry.getValue());
            } else if (entry.getValue() instanceof br.com.bi.model.entity.metadata.Property) {
                levels.add(((br.com.bi.model.entity.metadata.Property) entry.getValue()).getLevel());
            }
        }

        return levels;
    }

    /**
     * Produz a cláusula WHERE da consulta, baseado nos joins resultantes das referências
     * para os níveis da consulta.
     * @return
     */
    private String whereExpression(StringBuilder data) {
        List<String> joins = new ArrayList<String>();

        List<Level> levels = levelsPresent();

        // do nível mais alto vai descendo e adicionando os joins até chegar o nível
        // mais baixo e assim juntá-lo ao cubo
        for (Level level : levels) {
            List<Level> lowerLevels = level.getLowerLevels();

            for (int i = 0; i < lowerLevels.size(); i++) {
                // de duas em duas colunas, coloca o join na lista
                if (i > 0 & (i + 1) % 2 == 0) {
                    String upperColumn = TranslationUtils.columnExpression(lowerLevels.get(i - 1).getTableName(), lowerLevels.get(i - 1).getCodeProperty().getColumnName());

                    String thisColumn = TranslationUtils.columnExpression(lowerLevels.get(i).getTableName(), lowerLevels.get(i).getUpperLevelJoinColumn());

                    joins.add(thisColumn + " = " + upperColumn);
                }
            }

            // o nível mais baixo (cujo índice é o maior) é o nível que faz junção com o cubo,
            // e indiretamente liga todos os níveis superiores também.
            Collections.sort(lowerLevels, new Comparator<Level>() {

                public int compare(Level level1, Level level2) {
                    return Integer.valueOf(level1.getIndice()).compareTo(Integer.valueOf(level2.getIndice()));
                }
            });

            Level lowestLevel = lowerLevels.get(lowerLevels.size() - 1);

            for (CubeLevel cubeLevel : cube.getCubeLevelList()) {
                if (cubeLevel.getLevel().getId() == lowestLevel.getId()) {
                    joins.add(TranslationUtils.columnExpression(cube.getTableName(), cubeLevel.getJoinColumn()) + " = " + TranslationUtils.columnExpression(lowestLevel.getTableName(), lowestLevel.getCodeProperty().getColumnName()));
                }
            }
        }

        if (!joins.isEmpty()) {
            for (int i = 0; i < joins.size(); i++) {
                data.append(joins.get(i));

                if (i < joins.size() - 1) {
                    data.append(" and ");
                }
            }
        }

        return data.toString();
    }

    private String translateLevel(br.com.bi.model.entity.metadata.Level level) {
        StringBuilder sb = new StringBuilder();

        sb.append(TranslationUtils.columnExpression(level.getTableName(), level.getCodeProperty().getColumnName()));

        return sb.toString();
    }

    private String translateProperty(br.com.bi.model.entity.metadata.Property property) {
        StringBuilder sb = new StringBuilder();

        sb.append(TranslationUtils.columnExpression(property.getLevel().getTableName(), property.getColumnName()));

        return sb.toString();
    }
}
